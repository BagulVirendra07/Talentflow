{"ast":null,"code":"import { Dexie } from 'dexie';\nimport React from 'react';\nfunction useObservable(observableFactory, arg2, arg3) {\n  // Resolve vars from overloading variants of this function:\n  var deps;\n  var defaultResult;\n  if (typeof observableFactory === 'function') {\n    deps = arg2 || [];\n    defaultResult = arg3;\n  } else {\n    deps = [];\n    defaultResult = arg2;\n  }\n  // Create a ref that keeps the state we need\n  var monitor = React.useRef({\n    hasResult: false,\n    result: defaultResult,\n    error: null\n  });\n  // We control when component should rerender. Make triggerUpdate\n  // as examplified on React's docs at:\n  // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n  var _a = React.useReducer(function (x) {\n    return x + 1;\n  }, 0);\n  _a[0];\n  var triggerUpdate = _a[1];\n  // Memoize the observable based on deps\n  var observable = React.useMemo(function () {\n    // Make it remember previous subscription's default value when\n    // resubscribing.\n    var observable = typeof observableFactory === 'function' ? observableFactory() : observableFactory;\n    if (!observable || typeof observable.subscribe !== 'function') {\n      if (observableFactory === observable) {\n        throw new TypeError(\"Given argument to useObservable() was neither a valid observable nor a function.\");\n      } else {\n        throw new TypeError(\"Observable factory given to useObservable() did not return a valid observable.\");\n      }\n    }\n    if (!monitor.current.hasResult && typeof window !== 'undefined' // Don't do this in SSR\n    ) {\n      // Optimize for BehaviorSubject and other observables implementing getValue():\n      if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n        if (typeof observable.getValue === 'function') {\n          monitor.current.result = observable.getValue();\n          monitor.current.hasResult = true;\n        } else {\n          // Find out if the observable has a current value: try get it by subscribing and\n          // unsubscribing synchronously\n          var subscription = observable.subscribe(function (val) {\n            monitor.current.result = val;\n            monitor.current.hasResult = true;\n          });\n          // Unsubscribe directly. We only needed any synchronous value if it was possible.\n          if (typeof subscription === 'function') {\n            subscription();\n          } else {\n            subscription.unsubscribe();\n          }\n        }\n      }\n    }\n    return observable;\n  }, deps);\n  // Integrate with react devtools:\n  React.useDebugValue(monitor.current.result);\n  // Subscribe to the observable\n  React.useEffect(function () {\n    var subscription = observable.subscribe(function (val) {\n      var current = monitor.current;\n      if (current.error !== null || current.result !== val) {\n        current.error = null;\n        current.result = val;\n        current.hasResult = true;\n        triggerUpdate();\n      }\n    }, function (err) {\n      var current = monitor.current;\n      if (current.error !== err) {\n        current.error = err;\n        triggerUpdate();\n      }\n    });\n    return typeof subscription === 'function' ? subscription // Support observables that return unsubscribe directly\n    : subscription.unsubscribe.bind(subscription);\n  }, deps);\n  // Throw if observable has emitted error so that\n  // an ErrorBoundrary can catch it\n  if (monitor.current.error) throw monitor.current.error;\n  // Return the current result\n  return monitor.current.result;\n}\nfunction useLiveQuery(querier, deps, defaultResult) {\n  return useObservable(function () {\n    return Dexie.liveQuery(querier);\n  }, deps || [], defaultResult);\n}\nfunction usePermissions(firstArg, table, obj) {\n  if (!firstArg) throw new TypeError(\"Invalid arguments to usePermissions(): undefined or null\");\n  var db;\n  if (arguments.length >= 3) {\n    if (!('transaction' in firstArg)) {\n      // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n      // First arg is  ensures first arg is a Dexie instance\n      throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance\");\n    }\n    if (typeof table !== 'string') throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 2nd arg must be string\");\n    if (!obj || typeof obj !== 'object') throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object\");\n    db = firstArg;\n  } else {\n    if (firstArg instanceof Dexie) throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.\");\n    if (typeof firstArg.table === 'function' && typeof firstArg.db === 'object') {\n      db = firstArg.db;\n      obj = firstArg;\n      table = firstArg.table();\n    } else {\n      throw new TypeError(\"Invalid arguments to usePermissions(). \" + \"Expected usePermissions(entity: DexieCloudEntity) or \" + \"usePermissions(db: Dexie, table: string, obj: DexieCloudObject)\");\n    }\n  }\n  if (!('cloud' in db)) throw new Error(\"usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.\");\n  if (!('permissions' in db.cloud)) throw new Error(\"usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.\");\n  return useObservable(\n  // @ts-ignore\n  function () {\n    return db.cloud.permissions(obj, table);\n  }, [obj.realmId, obj.owner, table]);\n}\nvar gracePeriod = 100; // 100 ms = grace period to optimize for unload/reload scenarios\nvar fr = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(function (doc) {\n  // If coming here, react effect never ran. This is a fallback cleanup mechanism.\n  var DexieYProvider = Dexie['DexieYProvider'];\n  if (DexieYProvider) DexieYProvider.release(doc);\n});\nfunction useDocument(doc) {\n  var _a, _b;\n  if (!fr) throw new TypeError('FinalizationRegistry not supported.');\n  var providerRef = React.useRef(null);\n  var DexieYProvider = Dexie['DexieYProvider'];\n  if (!DexieYProvider) {\n    throw new Error('DexieYProvider is not available. Make sure `y-dexie` is installed and imported.');\n  }\n  var unregisterToken = undefined;\n  if (doc) {\n    if (doc !== ((_a = providerRef.current) === null || _a === void 0 ? void 0 : _a.doc)) {\n      providerRef.current = DexieYProvider.load(doc, {\n        gracePeriod: gracePeriod\n      });\n      unregisterToken = Object.create(null);\n      fr.register(providerRef, doc, unregisterToken);\n    }\n  } else if ((_b = providerRef.current) === null || _b === void 0 ? void 0 : _b.doc) {\n    providerRef.current = null;\n  }\n  React.useEffect(function () {\n    if (doc) {\n      // Doc is set or changed. Unregister provider from FinalizationRegistry\n      // and instead take over from here to release the doc when component is unmounted\n      // or when doc is changed. What we're doing here is to avoid relying on FinalizationRegistry\n      // in all the normal cases and instead rely on React's lifecycle to release the doc.\n      // But there can be situations when react never calls this effect and therefore, we\n      // need to rely on FinalizationRegistry to release the doc as a fallback.\n      // We cannot wait with loading the document until the effect happens, because the doc\n      // could have been destroyed in the meantime.\n      if (unregisterToken) fr.unregister(unregisterToken);\n      var provider = DexieYProvider.for(doc);\n      if (provider) {\n        return function () {\n          DexieYProvider.release(doc);\n        };\n      } else {\n        // Maybe the doc was destroyed in the meantime.\n        // Can not happen if React and FinalizationRegistry works as we expect them to.\n        // Except if a user had called DexieYProvider.release() on the doc\n        throw new Error(\"FATAL. DexieYProvider.release() has been called somewhere in application code, making us lose the document.\");\n      }\n    }\n  }, [doc, unregisterToken]);\n  return providerRef.current;\n}\nexport { useDocument, useLiveQuery, useObservable, usePermissions };","map":{"version":3,"names":["useObservable","observableFactory","arg2","arg3","deps","defaultResult","monitor","React","useRef","hasResult","result","error","_a","useReducer","x","triggerUpdate","observable","useMemo","subscribe","TypeError","current","window","hasValue","getValue","subscription","val","unsubscribe","useDebugValue","useEffect","err","bind","useLiveQuery","querier","Dexie","liveQuery","usePermissions","firstArg","table","obj","db","arguments","length","Error","cloud","permissions","realmId","owner","gracePeriod","fr","FinalizationRegistry","doc","DexieYProvider","release","useDocument","providerRef","unregisterToken","undefined","load","Object","create","register","_b","unregister","provider","for"],"sources":["C:\\Users\\viren\\Trial 2\\node_modules\\dexie-react-hooks\\src\\useObservable.ts","C:\\Users\\viren\\Trial 2\\node_modules\\dexie-react-hooks\\src\\useLiveQuery.ts","C:\\Users\\viren\\Trial 2\\node_modules\\dexie-react-hooks\\src\\usePermissions.ts","C:\\Users\\viren\\Trial 2\\node_modules\\dexie-react-hooks\\src\\useDocument.ts"],"sourcesContent":["import React from 'react';\nexport interface InteropableObservable<T> {\n  subscribe(\n    onNext: (x: T) => any,\n    onError?: (error: any) => any\n  ): (() => any) | { unsubscribe(): any };\n  getValue?(): T; // For BehaviorSubject\n  hasValue?(): boolean; // For liveQuery observable returning false until a value is available\n}\n\nexport function useObservable<T, TDefault>(\n  observable: InteropableObservable<T>\n): T | undefined;\nexport function useObservable<T, TDefault>(\n  observable: InteropableObservable<T>,\n  defaultResult: TDefault\n): T | TDefault;\nexport function useObservable<T>(\n  observableFactory: () => InteropableObservable<T>,\n  deps?: any[]\n): T | undefined;\nexport function useObservable<T, TDefault>(\n  observableFactory: () => InteropableObservable<T>,\n  deps: any[],\n  defaultResult: TDefault\n): T | TDefault;\nexport function useObservable<T, TDefault>(\n  observableFactory:\n    | InteropableObservable<T>\n    | (() => InteropableObservable<T>),\n  arg2?: any,\n  arg3?: any\n) {\n  // Resolve vars from overloading variants of this function:\n  let deps: any[];\n  let defaultResult: TDefault;\n  if (typeof observableFactory === 'function') {\n    deps = arg2 || [];\n    defaultResult = arg3;\n  } else {\n    deps = [];\n    defaultResult = arg2;\n  }\n\n  // Create a ref that keeps the state we need\n  const monitor = React.useRef({\n    hasResult: false,\n    result: defaultResult as T | TDefault,\n    error: null as any,\n  });\n  // We control when component should rerender. Make triggerUpdate\n  // as examplified on React's docs at:\n  // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n  const [_, triggerUpdate] = React.useReducer((x) => x + 1, 0);\n\n  // Memoize the observable based on deps\n  const observable = React.useMemo(() => {\n    // Make it remember previous subscription's default value when\n    // resubscribing.\n    const observable =\n      typeof observableFactory === 'function'\n        ? observableFactory()\n        : observableFactory;\n    if (!observable || typeof observable.subscribe !== 'function') {\n      if (observableFactory === observable) {\n        throw new TypeError(\n          `Given argument to useObservable() was neither a valid observable nor a function.`\n        );\n      } else {\n        throw new TypeError(\n          `Observable factory given to useObservable() did not return a valid observable.`\n        );\n      }\n    }\n\n    if (!monitor.current.hasResult &&\n        typeof window !== 'undefined' // Don't do this in SSR\n       ) {\n      // Optimize for BehaviorSubject and other observables implementing getValue():\n      if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n        if (typeof observable.getValue === 'function') {\n          monitor.current.result = observable.getValue();\n          monitor.current.hasResult = true;\n        } else {\n          // Find out if the observable has a current value: try get it by subscribing and\n          // unsubscribing synchronously\n          const subscription = observable.subscribe((val) => {\n            monitor.current.result = val;\n            monitor.current.hasResult = true;\n          });\n          // Unsubscribe directly. We only needed any synchronous value if it was possible.\n          if (typeof subscription === 'function') {\n            subscription();\n          } else {\n            subscription.unsubscribe();\n          }\n        }\n      }\n    }\n    return observable;\n  }, deps);\n\n  // Integrate with react devtools:\n  React.useDebugValue(monitor.current.result);\n\n  // Subscribe to the observable\n  React.useEffect(() => {\n    const subscription = observable.subscribe(\n      (val) => {\n        const { current } = monitor;\n        if (current.error !== null || current.result !== val) {\n          current.error = null;\n          current.result = val;\n          current.hasResult = true;\n          triggerUpdate();\n        }\n      },\n      (err) => {\n        const { current } = monitor;\n        if (current.error !== err) {\n          current.error = err;\n          triggerUpdate();\n        }\n      }\n    );\n    return typeof subscription === 'function'\n      ? subscription // Support observables that return unsubscribe directly\n      : subscription.unsubscribe.bind(subscription);\n  }, deps);\n\n  // Throw if observable has emitted error so that\n  // an ErrorBoundrary can catch it\n  if (monitor.current.error) throw monitor.current.error;\n\n  // Return the current result\n  return monitor.current.result;\n}\n","import { Dexie } from 'dexie';\nimport { useObservable } from './useObservable';\n\nexport function useLiveQuery<T>(\n  querier: () => Promise<T> | T,\n  deps?: any[]\n): T | undefined;\nexport function useLiveQuery<T, TDefault>(\n  querier: () => Promise<T> | T,\n  deps: any[],\n  defaultResult: TDefault\n): T | TDefault;\nexport function useLiveQuery<T, TDefault>(\n  querier: () => Promise<T> | T,\n  deps?: any[],\n  defaultResult?: TDefault\n): T | TDefault {\n  return useObservable(\n    () => Dexie.liveQuery(querier),\n    deps || [],\n    defaultResult as TDefault\n  );\n}\n","import { Dexie } from 'dexie';\nimport { useObservable } from './useObservable';\n//import type { KeyPaths, TableProp } from 'dexie'; // Issue #1725 - not compatible with dexie@3.\n// Workaround: provide these types inline for now. When dexie 4 stable is out, we can use the types from dexie@4.\nexport type KeyPaths<T> = {\n  [P in keyof T]: \n    P extends string \n      ? T[P] extends Array<infer K>\n        ? K extends object // only drill into the array element if it's an object\n          ? P | `${P}.${number}` | `${P}.${number}.${KeyPaths<K>}` \n          : P | `${P}.${number}`\n        : T[P] extends (...args: any[]) => any // Method\n           ? never \n          : T[P] extends object \n            ? P | `${P}.${KeyPaths<T[P]>}` \n            : P \n      : never;\n}[keyof T];\nexport type TableProp<DX extends Dexie> = {\n  [K in keyof DX]: DX[K] extends {schema: any, get: any, put: any, add: any, where: any} ? K : never;\n}[keyof DX] & string;\n\n\ninterface DexieCloudEntity {\n  table(): string;\n  realmId: string;\n  owner: string;\n}\n\nexport interface PermissionChecker<T, TableName extends string> {\n  add(...tableNames: TableName[]): boolean;\n  update(...props: KeyPaths<T>[]): boolean;\n  delete(): boolean;\n}\n\nexport function usePermissions<T extends DexieCloudEntity>(\n  entity: T\n): PermissionChecker<\n  T,\n  T extends { table: () => infer TableName } ? TableName : string\n>;\nexport function usePermissions<\n  TDB extends Dexie,\n  T\n>(db: TDB, table: TableProp<TDB>, obj: T): PermissionChecker<T, TableProp<TDB>>;\nexport function usePermissions(\n  firstArg:\n    | Dexie\n    | {\n        realmId?: string;\n        owner?: string;\n        table?: () => string;\n        readonly db?: Dexie;\n      },\n  table?: string,\n  obj?: { realmId?: string; owner?: string }\n) {\n  if (!firstArg)\n    throw new TypeError(\n      `Invalid arguments to usePermissions(): undefined or null`\n    );\n  let db: Dexie;\n  if (arguments.length >= 3) {\n    if (!('transaction' in firstArg)) {\n      // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n      // First arg is  ensures first arg is a Dexie instance\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance`\n      );\n    }\n    if (typeof table !== 'string')\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 2nd arg must be string`\n      );\n    if (!obj || typeof obj !== 'object')\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object`\n      );\n    db = firstArg;\n  } else {\n    if (firstArg instanceof Dexie)\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.`\n      );\n\n    if (\n      typeof firstArg.table === 'function' &&\n      typeof firstArg.db === 'object'\n    ) {\n      db = firstArg.db!;\n      obj = firstArg;\n      table = firstArg.table();\n    } else {\n      throw new TypeError(\n        `Invalid arguments to usePermissions(). ` +\n          `Expected usePermissions(entity: DexieCloudEntity) or ` +\n          `usePermissions(db: Dexie, table: string, obj: DexieCloudObject)`\n      );\n    }\n  }\n  if (!('cloud' in db))\n    throw new Error(\n      `usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.`\n    );\n  if (!('permissions' in (db as any).cloud))\n    throw new Error(`usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.`)\n  return useObservable(\n    // @ts-ignore\n    () => db.cloud.permissions(obj, table),\n    [obj.realmId, obj.owner, table]\n  );\n}\n","import { Dexie } from 'dexie';\nimport React from 'react';\n\n// Using import('y-dexie') and import('yjs') to not break the build if y-dexie or yjs are not installed.\n// (these two libries are truly optional and not listed in neither peerDependencies nor optionalDependencies)\n// We want the compiler to not complain about missing imports, so we use type imports.\n// Runtime, we will detect if y-dexie is available and use it via Dexie['DexieYProvider'].\n\ntype DexieYProvider = import('y-dexie').DexieYProvider;\ntype DexieYProviderConstructor = typeof import('y-dexie').DexieYProvider;\ntype YDoc = import('yjs').Doc;\n\nconst gracePeriod = 100 // 100 ms = grace period to optimize for unload/reload scenarios\n\nconst fr = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry((doc: YDoc) => {\n  // If coming here, react effect never ran. This is a fallback cleanup mechanism.\n  const DexieYProvider = Dexie['DexieYProvider'] as DexieYProviderConstructor;\n  if (DexieYProvider) DexieYProvider.release(doc);\n});\n\nexport function useDocument(\n  doc: YDoc | null | undefined\n): DexieYProvider | null {\n  if (!fr) throw new TypeError('FinalizationRegistry not supported.');\n  const providerRef = React.useRef<DexieYProvider | null>(null);\n  const DexieYProvider = Dexie['DexieYProvider'] as DexieYProviderConstructor;\n  if (!DexieYProvider) {\n    throw new Error('DexieYProvider is not available. Make sure `y-dexie` is installed and imported.');\n  }\n  let unregisterToken: object | undefined = undefined;\n  if (doc) {\n    if (doc !== providerRef.current?.doc) {\n      providerRef.current = DexieYProvider.load(doc, { gracePeriod });\n      unregisterToken = Object.create(null);\n      fr.register(providerRef, doc, unregisterToken);\n    }\n  } else if (providerRef.current?.doc) {\n    providerRef.current = null;\n  }\n  React.useEffect(() => {\n    if (doc) {\n      // Doc is set or changed. Unregister provider from FinalizationRegistry\n      // and instead take over from here to release the doc when component is unmounted\n      // or when doc is changed. What we're doing here is to avoid relying on FinalizationRegistry\n      // in all the normal cases and instead rely on React's lifecycle to release the doc.\n      // But there can be situations when react never calls this effect and therefore, we\n      // need to rely on FinalizationRegistry to release the doc as a fallback.\n      // We cannot wait with loading the document until the effect happens, because the doc\n      // could have been destroyed in the meantime.\n      if (unregisterToken) fr.unregister(unregisterToken);\n      let provider = DexieYProvider.for(doc);\n      if (provider) {\n        return () => {\n          DexieYProvider.release(doc);\n        }\n      } else {\n        // Maybe the doc was destroyed in the meantime.\n        // Can not happen if React and FinalizationRegistry works as we expect them to.\n        // Except if a user had called DexieYProvider.release() on the doc\n        throw new Error(`FATAL. DexieYProvider.release() has been called somewhere in application code, making us lose the document.`);\n      }\n    }\n  }, [doc, unregisterToken]);\n  return providerRef.current;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}